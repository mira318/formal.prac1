Описание алгоритма

Будем поддерживать ответ для каждого элемента стека, образующегося при разборе выражения в обратной польской записи 
и для каждого возможного значения l.
Остатков по модулю k всего k. Будем для каждого объекта в стеке хранить массив possible(реализовано через vector) из k элементов. 
Если из данного регулярного выражения можно получить слово длины n, где n mod k = l, и n минимально, то possible[l] = n,
если такого n не существует, то possible[l] = -1. Тогда ответ на задачу = possible[l] для заданного в условии l, если он существует,
и = INF, если possible[l] = -1. Осталось научиться поддерживать possible.
Для этого надо при добавлении буквы, завести для неё массив -1 1 -1 -1 ..., при добавлении 1 завести для него массив 0 -1 -1 -1 ....  
При конкатенации 2-х выражений новое выражение может иметь длину = любой возможной сумме длин конкатенируемых выражений, следовательно
используем декартово произведение и возьмём минимум.
При логическом или (сложении) 2-х выражений новое выражение может иметь длину = длине любого из старых выражений, следовательно
возьмём минимум из возможных 2-х.
При возведении в степень * будем умножать все возможные длины старого выражения на 0, 1, 2 ... k - 1 обновлять и брать минимум, 
где необходимо.

Докажем корректность: по индукции покажем, что массив для каждой части выражения удовлетворяет описанным свойствам после каждого шага.
База: для всех регулярных выражений длины 1 массив possible построен верно: из буквы можно получить только букву длины 1, 
из 1 можно получить только пустое слово длины 0.
Переход: пусть до некоторой длины m массивы possible, для регулярных выражений, в которых <= m символов построены верно. Тогда выражения 
большей длины могут быть получены 3-мя способами:
1)Конкатенация: тогда если возможные длины старых выражений были a1, a2 ... и b1, b2 ..., то новое выражение может иметь длину a1 + b1,
a1 + b2, ..., a2 + b1 .... Cложим все возможные пары за O(k^2). Заметим, что если какая-то длина по mod k получилась 2 и более раз,
то более длинные случаи можно не учитывать: если в слове заменить их на более короткие, то значения длины по mod k не изменится,
а значение без модуля увеличится, мы же хотим минимизировать значение без модуля при фиксированном значении с модулем.

2)Сложение: тогда если возможные длины старых выражений были a1, a2 ... и b1, b2 ..., то новое выражение может иметь длину a1, b1, 
a2, b2 ... тогда будем перебирать длину нового выражения за O(k) и проверять, есть ли она среди длин старых выражений. Заметим,
что если какая-то длина по mod k получилась 2 и более раз, то более длинные случаи можно не учитывать: если в слове заменить их на
более короткие, то значения длины по mod k не изменится, а значение без модуля увеличится, мы же хотим минимизировать значение без 
модуля при фиксированном значении с модулем.

3)Возведение в степень: тогда если возможная длина старого выражения была a1, a2 ..., то новое выражение может иметь длину 0, a1,
2 * a1, a2, 2 * a2 ... следовательно будем перебирать длину старого выражения и множитель за O(k^2). Дальше перебирать множитель 
не нужно т. к. ai * k = 0 mod k, ai * (k + 1) = ai  mod k .... Заметим, что если какая-то длина по mod k получилась 2 и более раз,
то более длинные случаи можно не учитывать: если в слове заменить их на более короткие, то значения длины по mod k не изменится, 
а значение без модуля увеличится, мы же хотим минимизировать значение без модуля при фиксированном значении с модулем.

Остальные действия над стеком образуют новые части регулярных выражений длины 1 или 0, значит их можно считать разобранными в базе.

Итак, переход доказан, алгоритм поддерживает указанный инвариант. При длине части регулярного выражения равной длине всего регулярного
выражения мы получим ответ на задачу. 
Асимптотика:
O(k^2 * |a|) по времени
O(k^2 * |a|) по памяти
